# 1주차 Day 1: 행렬 연산 최적화 보고서

## 1. 개요
Deep Learning Framework의 핵심인 행렬 곱셈(Matrix Multiplication)을 구현하고,
메모리 접근 패턴(Cache Locality)과 빌드 모드에 따른 성능 차이를 측정함.

## 2. 성능 측정 결과 (1000x1000 행렬 곱셈)
| 구분 | 반복문 순서 | 빌드 모드 | 소요 시간 | 비고 |
| :--- | :--- | :--- | :--- | :--- |
| **초기 버전** | `i-j-k` | Debug | 약 7.3s | 캐시 미스 다수 발생 |
| **알고리즘 최적화** | `i-k-j` | Debug | 약 5.4s | **약 26% 성능 향상** (공간/시간 지역성 활용) |
| **최종 최적화** | `i-k-j` | **Release** | **0.67s** | **약 10배 성능 향상** (Inlining + 최적화) |

## 3. 핵심 배움 (Key Learnings)

### A. 캐시 지역성 (Cache Locality)
- **현상:** 수학적으로 동일한 $O(N^3)$ 알고리즘이라도, 반복문 순서(`i-j-k` vs `i-k-j`)에 따라 속도 차이가 심함.
- **원인:** CPU 캐시 메모리는 데이터를 블록 단위로 가져옴. `i-k-j` 순서는 가져온 데이터를 끝까지 재사용(Reuse)하지만, `i-j-k`는 데이터를 띄엄띄엄 접근하여 캐시 미스(Cache Miss)를 유발함.

### B. C++ 빌드 모드 (Debug vs Release)
- **Debug:** 디버깅을 위한 안전장치와 심볼이 포함되어 느림.
- **Release:** 컴파일러가 강력한 최적화(`-O3`, 함수 인라인 등)를 수행하여 실제 성능을 냄.
- **결론:** 성능 측정은 반드시 **Release 모드**에서 해야 함.

### C. 연산자 오버로딩 (Operator Overloading)
- C++의 `operator()` 문법을 활용하여, 행렬 객체를 함수처럼 `A(i, j)` 형태로 직관적으로 접근하도록 구현함 (**Ex.** `operator*` 메소드를 사용할 때 객체 두개를 `A*B` 형태로 사용 가능)